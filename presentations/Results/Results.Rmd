---
title: "Results"
output:
  pdf_document:
    keep_tex: yes
header-includes:
- \usepackage{caption}
- \captionsetup[figure]{labelformat=empty}
bibliography: "references.bib"
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(cache = T,
                      cache.path = "_cache/",
                      echo = F,
                      message = F, 
                      warning = F)

library("kableExtra")
library("tidyverse")
library("ggpubr")

# Global Variables-------------
new_cases.threshold = 10
```

## A Simple Ratio for Estimating $R_t$

If we assume that majority of secondary infection caused by a primary case occur at the mean generation interval of the infection ($D$), then the $R_t$ on day $t$ can be estimated as the ratio of the number of new cases ($I$) on day $t+D$ and day $t$.

$$R_t \approx \frac{I_{t+D}}{I_t}$$

However, reporting of new cases easily violates the assumption that the majority of secondary infections occur $D$ days afte the primary infection for two reasons. First, the actual transmission of the virus doesn't conform to a rigid schedule. Two, there is inevitable variance in the timing of when new cases are reported (e.g. new cases are typically reported less over weekends). We can handle these two violations of the assumption by estimating $R_t$ as the ratio of the sums of new cases within two time periods ( size $\tau$ days, with the center of the time periods being on days $t$ and $t+D$). By considering the sum of new cases within larger time periods (e.g. 7 days), we capture secondary infections that didn't occur exactly $D$ days from the primary infection and we also counteract variation in new case reporting. 

$$ R_t \approx \frac{\sum_{t - \frac{\tau}{2} + D}^{t + \frac{\tau}{2} + D}I_i}{\sum_{t - \frac{\tau}{2}}^{t + \frac{\tau}{2}}I_i}$$
<!---
Since it is nearly impossible for any public health programs to identify all new cases of infection each day, the reported new cases represent only a subset of the total cases. For estimation $R_t$ to be accurate, it depends on how this subset is selected in a few ways. First, the porportion of the total represented by this subset cannot change drastically between the two reporting periods (e.g. if the porportion of the population that is tested drastically increases between the two reporting periods, then $R_t$ will appear artificially inflated). Second, the demographics that influence susceptibility to the disease (or testing positive) of the people reported cannot change drastically between the reporting periods (e.g. only testing the elderly in one time period, and then switching to testing non-elderly will likely affect $R_t$ estimations). Third, ultimately the change in cases of the subset needs to reflect the rate of change of the entire population (e.g. if...)
--->

## Performance of the Simple Ratio estimation of $R_t$

```{r}
tbl_1 = read_csv("table_1 - Description of Rt Estimation Methods.csv")

tbl_1 %>%
kable(., "latex", align="l", booktabs=TRUE, escape = F, caption = "Methods for Estimating $R_t$") %>%
  kable_styling(full_width = F)%>%
  column_spec(1, width = "8em", bold = T, color = "black")%>%
  column_spec(2, width = "28em") %>%
  column_spec(3, width = "8em")
```

To assess the performance of this simple ratio method of estimating $R_t$, we compared it to three previously published methods of estimating $R_t$ (**Table 1**)[@coriNewFrameworkSoftware2013; @wallingaDifferentEpidemicCurves2004; @wallingaHowGenerationIntervals2007]. We calculated the absolute difference in daily $R_t$ esimations between the four methods for the current SARS-CoV-2 pandemic in 10 countries, 10 US states, and 10 US counties (identified in the **Methods** section). We only compared days in which the number of new cases was greater than 10, because there is much greater fluctuation in $R_t$ estimations at low numbers of new cases (**Figure S1**). 

```{r baseline_parameters_analysis}

# Load Data--------
data_fig1 = read_csv("DATA - baseline_parameters.csv")
data_fig1 = data_fig1 %>% dplyr::select(region, date, new_cases, contains(".R_Mean"))
data_fig1 = data_fig1 %>% rename(`Simple Ratio` = "Simple Ratio.R_mean",
                                 Cori = "Cori.R_mean",
                                 `Walinga & Teunis` = "WT.R_mean",
                                 `Walinga & Lispsitch` = "WL.R_mean")

# Create Pairs---------
pairs = names(data_fig1)[4:7] %>% combn(.,2) %>% split(., col(.))

data_fig1 = map(pairs, function(x) data_fig1 %>% 
                            dplyr::select(1:3, x[1], x[2]) %>% 
                            rename(R_1 = x[1], R_2 = x[2]) %>%
                            mutate(Method_1 = x[1], Method_2 = x[2])
           )
data_fig1 = bind_rows(data_fig1)
data_fig1 = data_fig1 %>% unite(col = "Comparison", Method_1, Method_2, sep=" vs ", remove = F)

data_fig1<- data_fig1 %>% 
  mutate(Comparison = factor(Comparison, levels = c("Simple Ratio vs Cori", 
                                                    "Simple Ratio vs Walinga & Lispsitch",
                                                    "Simple Ratio vs Walinga & Teunis",
                                                    "Cori vs Walinga & Lispsitch",
                                                    "Cori vs Walinga & Teunis",
                                                    "Walinga & Teunis vs Walinga & Lispsitch")))


# Calculate Error-------------
data_fig1 = data_fig1 %>% mutate(error = abs(R_1 - R_2)) 

error_with_simple_ratio.summary = data_fig1 %>% 
  filter(new_cases >= new_cases.threshold) %>%
  filter(Method_1 == "Simple Ratio") %>%
  .$error %>% 
  summary()
  
# Statistical test of error -----------------

ttest_fig1 = data_fig1 %>% 
  filter(new_cases >= new_cases.threshold) %>% 
  mutate_at(4:5, log) %>%
  t.test(error ~ (Method_1 == "Simple Ratio"), data=.)


```

Using baseline parameters (generation interval with mean 4 days and standard deviation of 3 days [@ganyaniEstimatingGenerationInterval2020; @nishiuraCorrectingActualReproduction2010] and $\tau$ of size 7 days), we find that the simple ratio method agrees well with the 3 other methods (**Figure 1**). The interquaritle range (IQR) for absolute difference between the simple ratio method and other methods was `r round(error_with_simple_ratio.summary[2],2)` to `r round(error_with_simple_ratio.summary[3],2)`. There was a not a significant difference between the distribution of absolute differences when comparing simple ratio method to previously published methods versus when comparing  previously published methods to one another (p = `r round(ttest_fig1$p.value, 2)` by *students t-test*, **Figure 1B**). 


```{r baseline_parameters_fig, fig.wdith = 12, fig.height = 6, fig.cap = "**Figure 1. Comparison of $R_t$ Esimation between 4 methods using baseline parameters.** Data represents absolute differences in daily $R_t$ estimations between 4 different methods for 30 randomly selected regions. Only days with 10 or more new cases were included in analysis (**Figure S2**). (**A**) Scatter plots comparing daily $R_t$ estimations between the labeled methods. Dotted line represents y = x line. Outliers were removed. (**B**) Boxplot showing distribution of absolute differences in daily $R_t$ between the labeled estimation methods. The absolute differences derived from comparing the simple ratio method to published methods is not significantly different than the absolute difference derived from comparing published methods."}

# Primary Figure -----------------

plot_func = function(df_) {
  
  # Stats on Error
  median_error = round(median(df_$error, na.rm=T),2)
  `095_quantile_error` = round(quantile(df_$error, 0.95, na.rm=T),2)
  
  # Remove outliers
  summary.R1 = summary(df_$R_1)
  Q3.R1 = summary.R1[5]
  Q1.R1 = summary.R1[2]
  IQR.R1 = Q3.R1 - Q1.R1
  
  summary.R2 = summary(df_$R_2)
  Q3.R2 = summary.R2[5]
  Q1.R2 = summary.R2[3]
  IQR.R2 = Q3.R2 - Q1.R2
    
  df_ = df_ %>%
    filter(R_1 <= Q3.R1 + 1.5*IQR.R1) %>%
    filter(R_1 >= Q1.R1 - 1.5*IQR.R1) %>%
    filter(R_2 <= Q3.R2 + 1.5*IQR.R2) %>%
    filter(R_2 >= Q1.R2 - 1.5*IQR.R2)

  p = ggplot(df_) +
    geom_point(aes(R_1, R_2), alpha=0.2) +
    geom_abline(slope = 1, intercept = 0, linetype = 2) +
    labs(x = df_$Method_1[1], y = df_$Method_2[1]) + 
    theme_pubr() + 
    theme(text = element_text(size=10))

  return(p)
}

panel_A <- data_fig1 %>%
            filter(new_cases > new_cases.threshold) %>%
            split(f = .$Comparison) %>%
            map(., plot_func) 

panel_A = do.call(ggarrange, c(panel_A, ncol=3, nrow=2))

panel_B = data_fig1 %>%
            filter(new_cases > new_cases.threshold) %>%
            mutate(analysis_group = factor(Method_1 != "Simple Ratio")) %>%
            mutate(analysis_group = fct_recode(analysis_group, 
                                      `Comparison With\nSimple Ratio Method` = "FALSE", 
                                      `Comparison Between\nPublished Methods` = "TRUE"))

levels(panel_B$Comparison) = gsub("vs ", "vs\n", levels(panel_B$Comparison))

panel_B = panel_B %>%  
  ggplot(aes(x = analysis_group, y = error)) + 
    geom_boxplot(aes(fill = Comparison)) + 
    scale_y_log10(labels = scales::comma) + 
    labs(x = "", y = "Absolute Difference") + 
    theme_pubr() + 
    theme(legend.title = element_blank(),
          legend.position = "right",
          text = element_text(size=10))

fig_1 = ggarrange(panel_A, panel_B, nrow = 2, labels = c("A","B"), heights=c(6,4))
fig_1

# Figure Supplements ----------------

fig_S1 = data_fig1 %>% filter(new_cases > 0) %>%
  ggplot() + geom_point(aes(x = new_cases, y = error), alpha=0.2) + 
  scale_y_log10(labels = scales::comma) + 
  scale_x_log10() + 
  labs(x = "number of new cases", y = "Absolute Difference in Rt Estimation") + 
  facet_wrap(~Comparison) + 
  theme_pubr()

fig_S2.A = data_fig1 %>% filter(new_cases > 0) %>%
            split(f = .$Comparison) %>%
            map(., plot_func) 
fig_S2.A = do.call(ggarrange, c(fig_S2.A, ncol=3, nrow=2))

fig_S2.B = data_fig1 %>%
            mutate(analysis_group = factor(Method_1 != "Simple Ratio")) %>%
            mutate(analysis_group = fct_recode(analysis_group, 
                                      `Comparison With\nSimple Ratio Method` = "FALSE", 
                                      `Comparison Between\nPublished Methods` = "TRUE"))

levels(fig_S2.B$Comparison) = gsub("vs ", "vs\n", levels(fig_S2.B$Comparison))

fig_S2.B = fig_S2.B %>% filter(new_cases > 0) %>%
  ggplot(aes(x = analysis_group, y = error)) + 
    geom_boxplot(aes(fill = Comparison)) + 
    scale_y_log10(labels = scales::comma) + 
    labs(x = "", y = "Absolute Difference") + 
    theme_pubr() + 
    theme(legend.title = element_blank(),
          legend.position = "right",
          text = element_text(size=10))

fig_S2 = ggarrange(panel_A, panel_B, nrow = 2, labels = c("A","B"), heights=c(6,4))
```

We next assessed how the absolute differences would be affected if we modified the parameters involved in $R_t$ estimation - i.e. the generation interval and $\tau$. We found that the as $\tau$ is increased step-wise from 1 to 7 days, the median absolute difference (MAD) decreases between the different estimation methods (**Figure 2A**). In contrast, increasing the mean of the generation interval (stepwise from 2 to 6 days) results in an initial decrease in the MADs, but the increases in the median absolute error (**Figure 2B**). Full distributions of absolute errors can be found in **Figure S3-S5**.

```{r vary_parameters.analysis, fig.wdith = 12, fig.height = 6, fig.cap = "**Figure 2. Effects of modifying generation interval and $\tau$ on Median Absoluate Error of daily $R_t$ Esimations** Daily $R_t$ estimations  were made for 30 randomly selected regions using 4 different methods and the pairwise absolute difference between these estimations methods was calculated. Baseline parameters used for estimations were generation interval with a mean of 4 days and standard deviation of 3 days, and a $\tau$ of 7 days. While maintaing the baseline values for the other parameters, stepwise changes in were made to $\tau$ (**A**), the mean of the generation interval (**B**), and the standard deviation of the generation interval (**C**)."}

# Load Data--------

data_fig2_tau <- read_csv("./DATA - vary_tau_parameter.csv")
data_fig2_GT_mean <- read_csv("./DATA - vary_GT_mean_parameter.csv")
data_fig2_GT_sd <- read_csv("./DATA - vary_GT_sd_parameter.csv")

data_fig2 <- bind_rows(list(data_fig2_tau, data_fig2_GT_mean,data_fig2_GT_sd)) %>% unique()

data_fig2 = data_fig2 %>% dplyr::select(1:5, date, new_cases, contains(".R_Mean"))
data_fig2 = data_fig2 %>% rename(`Simple Ratio` = "Simple Ratio.R_mean",
                                 Cori = "Cori.R_mean",
                                 `Walinga & Teunis` = "WT.R_mean",
                                 `Walinga & Lispsitch` = "WL.R_mean")

# Create Pairs---------
pairs = names(data_fig2)[8:11] %>% combn(.,2) %>% split(., col(.))

data_fig2 = map(pairs, function(x) data_fig2 %>% 
                            dplyr::select(1:7, x[1], x[2]) %>% 
                            rename(R_1 = x[1], R_2 = x[2]) %>%
                            mutate(Method_1 = x[1], Method_2 = x[2])
           )
data_fig2 = bind_rows(data_fig2)
data_fig2 = data_fig2 %>% unite(col = "Comparison", Method_1, Method_2, sep=" vs ", remove = F)

data_fig2 <- data_fig2 %>% 
  mutate(Comparison = factor(Comparison, levels = c("Simple Ratio vs Cori", 
                                                    "Simple Ratio vs Walinga & Lispsitch",
                                                    "Simple Ratio vs Walinga & Teunis",
                                                    "Cori vs Walinga & Lispsitch",
                                                    "Cori vs Walinga & Teunis",
                                                    "Walinga & Teunis vs Walinga & Lispsitch")))
# Calculate Error-------------
data_fig2 = data_fig2 %>% mutate(error = abs(R_1 - R_2)) 

# Create Main Figure---------------
panel_A = data_fig2 %>%
            filter(GT_mean == 4 & GT_SD == 3) %>%
            filter(new_cases >= 10) %>%
            group_by(Comparison, tau) %>% 
            summarise(median_absolute_error = median(error, na.rm=T)) %>% ungroup() %>%
            mutate(tau = factor(tau)) %>%
            ggplot() + 
              geom_line(aes(x = tau, y = median_absolute_error,
                            group = factor(Comparison), color=factor(Comparison)), size = 1.5) +
              #scale_y_log10(labels = scales::comma) + 
              labs(x = "$\tau$ (days)", y = "Median Absolute Difference in $R_t$") + 
              theme_pubr() + 
              theme(legend.title = element_blank(),
              legend.position = "right",
              text = element_text(size=10))

panel_B = data_fig2 %>%
            filter(tau == 7 & GT_SD == 3) %>%
            filter(new_cases >= 10) %>%
            group_by(Comparison, GT_mean) %>% 
            summarise(median_absolute_error = median(error, na.rm=T)) %>% ungroup() %>%
            mutate(GT_mean = factor(GT_mean)) %>%
            ggplot() + 
              geom_line(aes(x = GT_mean, y = median_absolute_error, 
                            group = factor(Comparison), color=factor(Comparison)), size = 1.5) +
              labs(x = "mean generation interval (days)", y = "Median Absolute Difference in $R_t$") + 
              theme_pubr() + 
              theme(legend.title = element_blank(),
              legend.position = "right",
              text = element_text(size=10))
  
panel_C = data_fig2 %>%
            filter(tau == 7 & GT_mean == 4) %>%
            filter(new_cases >= 10) %>%
            group_by(Comparison, GT_SD) %>% 
            summarise(median_absolute_error = median(error, na.rm=T)) %>% ungroup() %>%
            mutate(GT_SD = factor(GT_SD)) %>%
            ggplot() + 
              geom_line(aes(x = GT_SD, y = median_absolute_error,
                            group = factor(Comparison), color=factor(Comparison)), size = 1.5) +
              labs(x = "standard deviation of generational interval (days)", y = "Median Absolute Difference in $R_t$") + 
              theme_pubr() + 
              theme(legend.title = element_blank(),
              legend.position = "right",
              text = element_text(size=10))

fig_2 = ggarrange(panel_A, panel_B, panel_C, ncol=3, labels=c("A", "B", "C"), common.legend = T)
fig_2

# Create Figure Supplements---------------

fig_S3 = data_fig2 %>%
            filter(GT_mean == 4 & GT_SD == 3) %>%
            filter(new_cases >= 10) %>%
            mutate(tau = factor(tau)) %>%
            ggplot(aes(x = tau, y = error)) + geom_boxplot() +
              facet_wrap(~Comparison) + 
              scale_y_log10(labels = scales::comma) + 
              labs(x = "tau (days)", y = "Absolute Difference") + 
              theme_pubr() + 
              theme(legend.title = element_blank(),
              legend.position = "right",
              text = element_text(size=10))

fig_S4 = data_fig2 %>%
            filter(tau == 7 & GT_SD == 3) %>%
            filter(new_cases >= 10) %>%
            mutate(GT_mean = factor(GT_mean)) %>%
            ggplot(aes(x = GT_mean, y = error)) + geom_boxplot() +
              facet_wrap(~Comparison) + 
              scale_y_log10(labels = scales::comma) + 
              labs(x = "mean of generation interval (days)", y = "Absolute Difference") + 
              theme_pubr() + 
              theme(legend.title = element_blank(),
              legend.position = "right",
              text = element_text(size=10))

fig_S5 = data_fig2 %>%
            filter(tau == 7 & GT_mean == 4) %>%
            filter(new_cases >= 10) %>%
            mutate(GT_SD = factor(GT_SD)) %>%
            ggplot(aes(x = GT_SD, y = error)) + geom_boxplot() +
              facet_wrap(~Comparison) + 
              scale_y_log10(labels = scales::comma) + 
              labs(x = "standard deviation of generation interval (days)", y = "Absolute Difference") + 
              theme_pubr() + 
              theme(legend.title = element_blank(),
              legend.position = "right",
              text = element_text(size=10))
```

## The $R_t$ Estimator Web App

We developed a Shiny web-app that allows users to estimate $R_t$ for the SARS-CoV-2 pandemic in all countries, all states in the United States,, and all counties in the United States over time with 95% confidence intervals (or credible intervals) for the estimations. The user can estimate R using all four different methods described above (**Table 1**).  

The user is able to select one or more geographic regions, and view a graph of how the $R_t$ changes over time for each of those regions. The user can modify parameters associated with the $R_t$ calculation, such as specifying the size of the smoothing window (the number days used for a rolling mean) to smooth the number of new cases per day, the mean and standard deviation of the generation interval, and the number of days to consider when calculating $R_t$ for each day ($\tau$). Additionally, the user can view the cumulative number of cases and new cases per day for each region selected. 

For each geographic region select, the web-app summarizes the the last 3 weeks of $R_t$ into colored score cards. For each week, the score card displays the range of $R_t$ point estimates. The color is based on the average limits of the confidence interval (CI) of $R_t$ for a particular week: the mean upper limit is below 1 (green); the mean point estimate is below 1 but the mean upper limit is above 1 (yellow); the mean point estimate is above 1 but the mean lower limit is below 1 (orange); the mean lower limit is above 1 (red). 

![](Figure_1.png)

**Figure 3. Interface of the Web-App**. The user selects one or more regions and a date-range of interest (A, red shaed region). For each of those selected regions and date-range, the $R_t$ value is displayed over time as a line graph on the top graph in the middle pane (B).  Additionally, for the lower graph, the user can toggle between viewing the cumulative number cases and new cases per day for each of the selected regions (C). The user controls parameters for calculating R: namely the size of the smoothing window for smoothing new cases per day,  method for calculating R, the mean and standard deviation of the generation interval, and the number of days used to calculate $R_t$ (D, green-shaded area). For each of the selected regions, a colored score card is displayed for each of the last three weeks based on the average $R_t$ and confidence interval of the estimations (E). If the user hovers over the graphs, additional information about the data is displayed in an information window (F). The date that the data and web-app were last updated are displayed (G). 

```{r Figure_S1, fig.cap = "**Figure S1. Absolute Difference in $R_t$ Estimations are greater when number of new cases are below 10.**"}
fig_S1
```

```{r Figure_S2, fig.height = 6, fig.cap = "**Figure S2. Data in Figure 1 include days in which new cases were between 1 to 9.**"}
fig_S2
```

```{r Figure_S3, fig.cap = "**Figure S3**"}
fig_S3
```

```{r Figure_S4, fig.cap = "**Figure S4**"}
fig_S4
```

```{r Figure_S5, fig.cap = "**Figure S5**"}
fig_S5
```

## References